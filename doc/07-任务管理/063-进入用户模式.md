# 进入用户模式

## 任务特权级环

![](./pics/Privilege_Level.drawio.svg)


## 任务状态段

用户与内核的切换需要 tss 中的着两个字段：

- ss0
- esp0


## 中断门处理过程

如果处理程序运行在低特权级，那么栈切换就会发生：

- 内核特权级的 栈段选择子(ss) 和 栈顶指针(esp) 将会从当前的 TSS 段中获得，在内核栈中将会压入用户态的 栈段选择子 和 栈顶指针；
- 保存当前的状态 eflags, cs, eip 到内核栈；
- 如果存在错误码的话，压入错误码。

如果处理器运行在相同的特权级，那么相同特权级的中断代码将被执行，不需要查找 tss 中的 ss 与 esp：

- 保存当前的状态 eflags, cs, eip 到内核栈；
- 如果存在错误码的话，压入错误码。


## 进入用户模式

到目前为止，所有的代码都在内核代码中执行，即 ds 与 ss 都分别为内核数据选择子与内核代码选择子；

为了进入用户态，需要改变 ds、ss 寄存器的指向，利用了 Return Oriented Programming 技术，模拟一次中断的发送，利用这段返回，将预先放入栈中的各个寄存器弹出；

可以看到，内核发生中断时，压栈的寄存器如下：

![](./pics/interrupt_context.drawio.svg)

用户发生中断，增加两个：esp3 与 ss3，即用户态中断前的 esp 与 ss：

![](./pics/interrupt_context_user2kernel.drawio.svg)

当用户态发生中断，CPU 根据此时的 cs 与 ss 段选择子得知全局描述符在 gdt 的索引，并且段选择子还保存了 DRP 信息，得知当前两段内存的特权级都是 3 级，所以需要先进入 0 级；

再查 TR 寄存器得知 tss 段在全局描述符的索引，找到那个全局描述符，再找到 tss 的内存，得知其中的 esp0 与 ss0，设置 CPU 的 esp 与 ss 寄存器为内核的，进入内核态，开始执行 int 指令。