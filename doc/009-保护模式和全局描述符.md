# 保护模式和全局描述符

系统刚启动时候，是 8086 模式，只能访问 1M 的内存，此时称为实模式；

实模式下，系统中的所有的内存、所有的功能对所有的程序都是一样的，甚至病毒，所以病毒可以完全控制计算机；

后来就引入了保护模式；


## 保护模式

保护模式保护的是：

- 信息；
- 寄存器，有些寄存器只能被操作系统访问；
- 高速缓存；
- 内存，通过描述符判断请求内存是操作系统还是应用程序；
- 外部设备，比如硬盘，CPU 只允许操作系统使用 `in` 与 `out` 指令对其读写；


## 全局描述符

用来描述一段内存，需要包含这些部分：

- 内存的起始位置
- 内存的长度 / 界限 = 长度 - 1
- 内存属性

这样操作系统可以根据这个表，判断其描述的内存的各种属性，比如是否可以被访问、是否可读、是数据还是代码等；

80386 全局描述符的 C 语言定义：

````c
typedef struct descriptor /* 共 8 个字节 */
{
    unsigned short limit_low;      // 段界限 0 ~ 15 位
    unsigned int base_low : 24;    // 基地址 0 ~ 23 位 16M
    unsigned char type : 4;        // 段类型
    unsigned char segment : 1;     // 1 表示代码段或数据段，0 表示系统段
    unsigned char DPL : 2;         // Descriptor Privilege Level 描述符特权等级 0 ~ 3
    unsigned char present : 1;     // 存在位，1 在内存中，0 在磁盘上
    unsigned char limit_high : 4;  // 段界限 16 ~ 19;
    unsigned char available : 1;   // 该安排的都安排了，送给操作系统吧
    unsigned char long_mode : 1;   // 64 位扩展标志
    unsigned char big : 1;         // 32 位 还是 16 位;
    unsigned char granularity : 1; // 粒度 4KB 或 1B
    unsigned char base_high;       // 基地址 24 ~ 31 位
} __attribute__((packed)) descriptor;
````

其中，当 segment 为 1 时，type 的四位可以分为：

$$
| X | C/E | R/W | A | 
$$

- A：Accessed 是否被 CPU 访问过；
- X：1 表示代码，0 表示数据；X 字段的不同，C/E 位与 R/W 位表示不同的含义；
- X = 1 时，此时内存为代码段，C/E 位为 C，R/W 位为 R：
    - C：表示是否依从代码段，表示应用程序是否可以直接跳转到这部分内存执行（执行时是否需要切换特权级）；
    - R：表示此内存是否可读（代码肯定不能写）；
- X = 0 时，此时内存为数据段，C/E 位为 E，R/W 位为 W：
    - E：0 时表示向上拓展、1 时表示向下拓展（栈向上拓展）；
    - W：表示此时数据是否可写；


## 全局描述符表 GDT

Global Descriptor Table，内存中的一个数组，每个元素是一个全局描述符：

````c
descriptor gdt[8192];
````

其中，第 0 个结构体内容的必须全部为 0，这是硬件产生的要求。所以可用的全局描述符最多有 8191 个；

全局描述符 gdt 保存在内存中，需要告诉其起始内存地址与长度：

使用类型这样一个数据结构，描述 gdt 的起始位置与长度：

````c
typedef struct pointer
{
    unsigned short limit; // size - 1
    unsigned int base;
} __attribute__((packed)) pointer;
````

在系统中真正保存 gdt 信息的是 gdtr 这个寄存器，用两个指令来操作：

````assembly
lgdt [gdt_ptr]; 加载 gdt
sgdt [gdt_ptr]; 保存 gdt
````


## 段选择子

gdt 也即全局段描述符表，保存很多个全局描述符，使用的使用要有一个索引来确定其中的某一个（数组的索引）；

段选择子就是用来做这个工作的，相当于一个数组索引。但其不仅是索引，还包含其他信息，其 C 结构体定义如下：

````c
typedef struct selector
{
    unsigned char RPL : 2;          // Request PL，特权级，对应全局描述符中的 DPL
    unsigned char TI : 1;           // 0 表示这个段选择子定位的是全局描述符表， 1 表示定位局部描述符表 
    unsigned short index : 13;      // 描述符表索引
} __attribute__((packed)) selector;
````

实模式下，段寄存器用来提供不足的地址线（加 003-主引导扇区），而包含模式下，读写内存之前要把对应的描述符起始地址放置在段寄存器中；

系统提供了以下段寄存器：cs / ds / es / ss。其中 cs 与 ss 表示代码段寄存器与栈段寄存器，其他两个的可以用作其他段。


## A20 线

8086 的内存只有 1M，只要 16 位的地址线；

而 80386 为 4G，为了兼容 8086，系统初始需要执行 8086 的程序，地址线只有 16 位，进入保护模式需要打开 A20 线；

开启 A20 线的方法是操作 0x92 端口；


## 启动保护模式

只要把 cr0 寄存器的第 0 为设置为 1 即可；
